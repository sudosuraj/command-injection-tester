#! /usr/bin/env python3
#
# Contact: starttls@fh-muenster.de
#
# Distributed under terms of the MIT license.

import select
import sys
import os
import socket
import ssl
import logging
import argparse
from enum import Enum
from pathlib import Path
import secrets
from typing import Callable, Union

Protocol = Enum("Protocol", ("IMAP", "POP3", "SMTP", "MANAGESIEVE"))

TRACE = 15
logging.addLevelName(TRACE, "TRACE")

default_ports = {
    Protocol.IMAP: 143,
    Protocol.POP3: 110,
    Protocol.SMTP: 587,
    Protocol.MANAGESIEVE: 4190,
}

DEFAULT_LOGDIR = "./logs"
DEFAULT_COMMENT = "commandinjectiontester"
DEFAULT_TIMEOUT = 2


def red(s): return f"\033[31m{s}\033[0m"
def green(s): return f"\033[32m{s}\033[0m"


class ServerTest:
    def __init__(self, protocol, logging_level, hostname, port, **kwargs):
        self.protocol = protocol
        self.logging_level = logging_level
        self.hostname = hostname
        self.port = port or default_ports.get(protocol)
        self.logdir = kwargs.get("logdir") or DEFAULT_LOGDIR
        self.comment = kwargs.get("comment") or DEFAULT_COMMENT
        self.timeout = kwargs.get("timeout") or DEFAULT_TIMEOUT

    def recv_from_ssl(self, sock):
        sock.setblocking(False)
        data = b""
        while True:
            r, _, _ = select.select([sock], [], [], self.timeout)
            if sock in r:
                try:
                    new = sock.recv(1024)
                except ssl.SSLError as e:
                    if e.errno != ssl.SSL_ERROR_WANT_READ:
                        raise
                    continue
                if not new:
                    break
                data += new
                while sock.pending():
                    data += sock.recv(sock.pending())
            else:
                break
        return data

    def _recv_plain(self, sock):
        resp = b""
        for _ in range(5):
            r, _, _ = select.select([sock], [], [], self.timeout)
            if sock in r:
                resp += sock.recv(1024)
            else:
                break
        return resp

    def _sanity_test(self, logger, context, pretls, posttls):
        try:
            with socket.create_connection((self.hostname, self.port), timeout=self.timeout) as sock:
                logger.info("Sanity test...")
                banner = self._recv_plain(sock)
                log_trace(logger, banner, True)

                for p in pretls:
                    log_trace(logger, p, False)
                    sock.send(p.encode())
                    log_trace(logger, self._recv_plain(sock), True)

                with context.wrap_socket(sock, server_hostname=self.hostname):
                    logger.debug("<----- TLS Handshake ----->")
                    for p in posttls:
                        sock.send(p.encode())
                        log_trace(logger, p, False)

                logger.info(green("Sanity test done"))
                return True
        except Exception:
            logger.exception(red("Sanity test failed"))
            return False

    def _smtp_starttls_supported(self, resp: bytes) -> bool:
        return b"STARTTLS" in resp

    def _smtp_starttls_accepted(self, sock, logger) -> bool:
        sock.send(b"STARTTLS\r\n")
        resp = self._recv_plain(sock)
        log_trace(logger, resp, True)
        return b"220" in resp

    def test_smtp_server(self, logger, context):
        with socket.create_connection((self.hostname, self.port), timeout=self.timeout) as sock:
            banner = self._recv_plain(sock)
            log_trace(logger, banner, True)

            sock.send(f"EHLO {self.comment}\r\n".encode())
            ehlo_resp = self._recv_plain(sock)
            log_trace(logger, ehlo_resp, True)

            if not self._smtp_starttls_supported(ehlo_resp):
                logger.info("STARTTLS not advertised — skipping injection test")
                return

            if not self._smtp_starttls_accepted(sock, logger):
                logger.info("STARTTLS not accepted — skipping injection test")
                return

            logger.debug("<----- TLS Handshake ----->")
            with context.wrap_socket(sock, server_hostname=self.hostname) as ssock:
                ssock.setblocking(False)

                resp = self.recv_from_ssl(ssock)
                if resp:
                    log_trace(logger, resp, True)
                    logger.info(green("No STARTTLS command injection detected"))
                else:
                    logger.info(green("No STARTTLS command injection detected"))

    def test_server(self):
        logger = self.get_logger()
        context = get_ssl_context()
        logger.info(f"Testing {self.protocol.name} server at {self.hostname}:{self.port}")

        if self.protocol == Protocol.SMTP:
            self.test_smtp_server(logger, context)

    def get_logger(self):
        logger = logging.getLogger(f"{self.hostname}_{self.protocol.name}")
        logger.handlers.clear()

        sh = logging.StreamHandler(sys.stdout)
        Path(self.logdir).mkdir(exist_ok=True)
        fh = logging.FileHandler(f"{self.logdir}/{self.hostname}_{self.protocol.name}.log")

        fmt = logging.Formatter(
            f"{self.protocol.name}: %(asctime)s - %(levelname)s - %(message)s",
            "%Y-%m-%d %H:%M:%S",
        )
        sh.setFormatter(fmt)
        fh.setFormatter(fmt)

        logger.addHandler(sh)
        logger.addHandler(fh)
        logger.setLevel(self.logging_level)
        return logger


def log_trace(logger, content, incoming):
    if isinstance(content, bytes):
        content = content.decode(errors="ignore")
    for line in content.splitlines():
        logger.log(TRACE, f"{'S' if incoming else 'C'}: {line}")


def get_ssl_context():
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    return ctx


def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("hostname")
    p.add_argument("--smtp", action="store_const", const=Protocol.SMTP)
    p.add_argument("--smtp-port", type=int)
    p.add_argument("--quiet", action="store_true")
    return p.parse_args()


if __name__ == "__main__":
    args = parse_args()
    logging_level = logging.INFO if args.quiet else logging.DEBUG
    st = ServerTest(
        protocol=args.smtp,
        logging_level=logging_level,
        hostname=args.hostname,
        port=args.smtp_port,
    )
    st.test_server()
